# This script reproduces the CYTOF analysis of human pancreatic tissues in Figures 1E,1G,1H,
# and Supplementary Figure 1D of the paper. It adopts the general approach and parts of the code from the
# following manuscript generated by Mark Robinson's group:
#
# Reference: Nowicka et al., CyTOF workflow: differential discovery in high-throughput high-dimensional
#            cytometry datasets. F1000 Research, 2017;6:748.

library(readxl)
library(grDevices)
library(RColorBrewer)
library(flowCore)
library(matrixStats)
library(ggplot2)
library(reshape2)
library(dplyr)
library(limma) # ?? NEED OR NOT
library(ggrepel)
library(pheatmap)
library(FlowSOM)
library(ConsensusClusterPlus)
library(ggridges)
library(Rtsne)
library(cowplot)

# setting the method of uniform discrete generation to the process used by R versions prior to 3.6.0.
# This makes outputs of processes relying on the set.seed command in the script reproducible as the analyses
# were original run in older versions of R.
RNGkind(sample.kind="Rounding")

# loading of sample metadata
sample_metadata <- read_excel("sample metadata.xlsx")                   
sample_metadata$condition <- as.factor(sample_metadata$condition)

# color definitions for plotting of treatment conditions
color_conditions <- c("dodgerblue3","red")

# loading raw FCS CyTOF files into the flowSet object (for the flowCore package)
raw_FCS <- read.flowSet(files = sample_metadata$file_name,path = "raw data",
                        transformation = FALSE, truncate_max_range = FALSE)
labels_new <- as.data.frame(read.csv("labels.csv"))                             # application of common marker labels to all FCS file data
new_desc <- as.vector(labels_new$desc)                                          # character vector which will replace the "desc" column contents with the flowSet with an R-friendly set of names
names(new_desc) <- labels_new$name                                              # adds the name to each element of the character vector above using the flowSet cytometer parameter names
markernames(raw_FCS) <- new_desc                                                # replacement of all parameter "desc" names by the newly defined names
file_metadata <- pData(parameters(raw_FCS[[1]])) 
analyzed_markers <- as.data.frame(read.csv("analyzed_markers.csv"))             # loading of the list of high quality markers to use for clustering
analyzed_markers <- as.vector(analyzed_markers$markers)

# defining a new function that will take existing expression data within each file and
# perform an arcsinh transformation on it after a division by 5. In addition the function will
# rename the columns in the expression matrix in each file (flowFrame object) with the antigens, not
# just the metal labels. We will also subset or pick the columns to keep instead of carrying all of the
# channels. At the end of the function, the transformed expression matrix with the selected and renamed
# phenotypic markers is deposited back into the flowFrame object (i.e. each individual sample file).

transform_expr <- function(x){                # defining the new function, cofactor of 5 used for CyTOF
  colnames(x) <- file_metadata$desc           # loading the antigen names to label the expression matrix
  expr <- exprs(x)                            # loading the expression matrix for each sample into a dataframe
  expr <- expr[,analyzed_markers]             # choosing of the markers to keep
  expr <- asinh(expr/5)                       # arcsinh transformation of expression intensity data
  exprs(x) <- expr                            # depositing of transformed data back into flowFrame object
  x
}

Transf_FCS <- fsApply(raw_FCS,transform_expr)  # apply transformation function to the raw dataset

# concatenation of transformed expression values from all of the files into a single matrix
collated_expr <- fsApply(Transf_FCS,exprs)

# creation of a matrix with the 1% and 99% values for each of the measured markers across all measured cells
rng <- colQuantiles(collated_expr, probs = c(0.01, 0.99))            # creates a matrix with 1% and 99% values for all parameters across all samples
expr01 <- t((t(collated_expr) - rng[, 1]) / (rng[, 2] - rng[, 1]))   # normalization of expression values between 0 and 1
expr01[expr01 < 0] <- 0                                              # all values < 0 are made 0
expr01[expr01 > 1] <- 1                                              # all values > 1 are made 1

# creation of a new character vector, where each element corresponds to an individual biological
# cell. Each element gets a label assigned to it from the sample metadata file to link the biological cell
# with the sample it came from. The fsApply argument here simply extracts the number of biological cells
# within each flowFrame object of the original flowSet and tells the rep function how many times to use
# a particular label from the character vector in the first argument of rep.
sample_ids <- rep(sample_metadata$sample_id, fsApply(raw_FCS, nrow))

# Principal components analysis of the samples based on MEDIAN expression of the markers within each sample
expr_median_sample_tbl <- data.frame(sample_id = sample_ids, collated_expr) %>%   # creating a df with medians
  group_by(sample_id) %>%                                                         # of each marker expression    
  summarize_all(funs(median))                                                     # within each sample
expr_median_sample <- t(expr_median_sample_tbl[, -1])               # the df needs to be transposed due to its format              
colnames(expr_median_sample) <- expr_median_sample_tbl$sample_id    # relabeling the columns in the transposed df

pca_out <- prcomp(expr_median_sample_tbl[,-(c(1,24))], center = TRUE, scale. = TRUE)   # PCA analysis of samples based on median expression

ggdf <- data.frame(PCA1 = pca_out$x[, 1], PCA2 = pca_out$x[, 2], sample_id = colnames(expr_median_sample)) # dataframe with 2D MDS positions of each sample
mm <- match(ggdf$sample_id, sample_metadata$sample_id)      # matching vector to add the condition associated with each sample on the next line
ggdf$condition <- sample_metadata$condition[mm]

ggplot(ggdf, aes(x = PCA1, y = PCA2, color = condition)) +         # PCA plot of samples based on marker expression levels
  geom_point(size = 8, alpha = 0.8) +
  theme_classic() +
  scale_color_manual(values = color_conditions) +
  coord_fixed(ratio = 2)

# generating the non-redundancy score (page 13-14 of the reference)
# defining the function - NRS - that will calculate the non-redundancy score for each marker from the
# entire dataset - how much does each measured marker contribute to the variability between samples

NRS <- function(x, ncomp = 3){                                 # ncomp -> number of PCA components to use in this analysis
  pr <- prcomp(x, center = TRUE, scale. = FALSE)               # PCA of the dataset
  z <- rep(1,ncol(x))                           # creates a vector including all 1's with element number equal to the number of flow markers
  y <- pr$sdev[1:ncomp]^2                       # calculates the variance for each of the PCA components
  score <- rowSums(outer(z, y) * abs(pr$rotation[,1:ncomp])) # score -> sum of (PC variance * PC loading) for each marker
  return(score)
}

nrs_sample <- fsApply(Transf_FCS, NRS, use.exprs = TRUE)   # apply the NRS function to the arcsinh-transformed flowSet
rownames(nrs_sample) <- sample_metadata$sample_id          # label all rows with corresponding sample IDs
nrs <- colMeans(nrs_sample, na.rm = TRUE)                  # create a separate object that includes the mean of score for each marker across all samples in the flowSet
lineage_markers_ord <- names(sort(nrs, decreasing = TRUE)) # order the markers in the nrs object from largest to smallest

# Colors for the heatmaps
color <- colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu")))(100)

# building the self-organizing map (SOM) with the FlowSOM package
fsom <- ReadInput(Transf_FCS, transform = FALSE, scale = FALSE)  # loading data into the FlowSOM package
set.seed(1234)                      # NEEDS TO BE VARIED A FEW TIMES TO TEST STABILITY OF DEFINED POPULATIONS
som <- BuildSOM(fsom, colsToUse = analyzed_markers)      # building the SOM
cell_clustering_som <- som$map$mapping[,1]  # extracts the mapping of each cell to its respective node in the SOM
codes <- som$map$codes                      # extracts marker expression in each of the 100 nodes of the SOM
plot_outdir <- "consensus_plots"

nmc <- 18                                   # DEFINES THE NUMBER OF FINAL POPULATIONS TO COLLAPSE THE SOM NODES INTO
                                            # for this dataset 18 was deemed an appropriate number after empirically testing
                                            # cluster number up to 30 subpopulations. The 18 clusters provide identification
                                            # of the main populations in the tissue and are collapsed into the final
                                            # 7 populations seen in the figures. The output from the ConsensusClusterPlus
                                            # package below in the "consensus_plots" folder was used to select this number.

mc <- ConsensusClusterPlus(t(codes), maxK = nmc, reps = 100,
                           pItem = 0.9, pFeature = 1, title = plot_outdir, plot = "png",
                           clusterAlg = "hc", innerLinkage = "average", finalLinkage = "average",
                           distance = "euclidean", seed = 1234)  # takes the 100 nodes from FlowSOM and further clusters them to 11 new clusters

code_clustering1 <- mc[[nmc]]$consensusClass                    # labels each node of the SOM with its cluster label (# of clusters again = nmc)
cell_clustering1 <- code_clustering1[cell_clustering_som]       # labels each cell in the dataset with its cluster assignment based on what node of the SOM it was in

# defining colors for clusters for heatmaps and other plots
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
                    "#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
                    "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
                    "#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
                    "#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
                    "#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")

# heatmap of the clusters defined within the SOM ordered by the medians of the expression markers
plot_clustering_heatmap_wrapper <- function(collated_expr, expr01, cell_clustering, color_clusters, cluster_merging = NULL){
  
  # Calculate the median expression of each marker within each cluster from the SOM above
  expr_median <- data.frame(collated_expr, cell_clustering = cell_clustering) %>%
    group_by(cell_clustering) %>% summarize_all(funs(median))
  expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
    group_by(cell_clustering) %>% summarize_all(funs(median))
  
  # Calculate proportion of cells within each cluster from the SOM clustering above
  clustering_table <- as.numeric(table(cell_clustering))
  clustering_prop <- round(clustering_table / sum(clustering_table) * 100, 2)
  
  # Sort the cell clusters with hierarchical clustering
  d <- dist(expr_median[, colnames(collated_expr)], method = "euclidean")
  cluster_rows <- hclust(d, method = "average")
  expr_heat <- as.matrix(expr01_median[, colnames(expr01)])
  rownames(expr_heat) <- expr01_median$cell_clustering
  
  # Colors and row labeling with previous calculated cell percentages for the heatmap coming up 
  color_heat <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(100)
  legend_breaks = seq(from = 0, to = 1, by = 0.2)
  labels_row <- paste0(expr01_median$cell_clustering, " (", clustering_prop ,"%)")
  
  # Annotation for the original clusters
  annotation_row <- data.frame(Cluster = factor(expr01_median$cell_clustering))
  rownames(annotation_row) <- rownames(expr_heat)
  color_clusters1 <- color_clusters[1:nlevels(annotation_row$Cluster)]
  names(color_clusters1) <- levels(annotation_row$Cluster)
  annotation_colors <- list(Cluster = color_clusters1)
  
  # Annotation for the merged clusters
  if(!is.null(cluster_merging)){
    cluster_merging$new_cluster <- factor(cluster_merging$new_cluster)
    annotation_row$Cluster_merging <- cluster_merging$new_cluster
    color_clusters2 <- color_clusters[1:nlevels(cluster_merging$new_cluster)]
    names(color_clusters2) <- levels(cluster_merging$new_cluster)
    annotation_colors$Cluster_merging <- color_clusters2
  }
  
  pheatmap(expr_heat, color = color_heat, cluster_cols = FALSE,
           cluster_rows = cluster_rows, labels_row = labels_row,
           display_numbers = FALSE, number_color = "black",
           fontsize = 8, fontsize_number = 6, legend_breaks = legend_breaks,
           annotation_row = annotation_row, annotation_colors = annotation_colors)
}

plot_clustering_heatmap_wrapper(collated_expr = collated_expr[, lineage_markers_ord],     # heatmap of the defined clusters from the SOM clustering
                                expr01 = expr01[, lineage_markers_ord],
                                cell_clustering = cell_clustering1, color_clusters = color_clusters)

# MANUAL CLUSTER MERGING - all previous analysis was done on the automatically identified clusters
# by ConsensusCluster package. The following code provides further supervised consolidation of clusters
# into biologically meaningful cell types using accepted annotations of cells

cluster_merging1 <- read_excel("cluster_merging.xlsx")
levels_clusters_merged <- c("CD4 T cells", "CD8 T cells", "Myeloid",
                            "Macrophages", "Marker negative", "Unknown")
cluster_merging1$new_cluster <- factor(cluster_merging1$new_cluster,
                                       levels = levels_clusters_merged)

mm <- match(cell_clustering1, cluster_merging1$original_cluster)             # matching vector generation
cell_clustering1m <- cluster_merging1$new_cluster[mm]                        # relabeling with new cluster assignment
mm <- match(code_clustering1, cluster_merging1$original_cluster)             # matching vector generation
code_clustering1m <- cluster_merging1$new_cluster[mm]                        # relabeling with new cluster assignment

plot_clustering_heatmap_wrapper(collated_expr = collated_expr[, lineage_markers_ord],
                                expr01 = expr01[, lineage_markers_ord], cell_clustering = cell_clustering1,
                                color_clusters = color_clusters, cluster_merging = cluster_merging1)

plot_clustering_heatmap_wrapper(collated_expr = collated_expr[, lineage_markers_ord],
                                expr01 = expr01[, lineage_markers_ord], cell_clustering = cell_clustering1m,
                                color_clusters = color_clusters)

# t-SNE and PCA visualization of the 100 nodes from the SOM 
# Get code sizes - i.e. how many cells were assigned to each node of the SOM
code_sizes <- table(factor(som$map$mapping[, 1], levels = 1:nrow(codes)))
code_sizes <- as.numeric(code_sizes)

# Run t-SNE on codes
set.seed(1234)
tsne_out <- Rtsne(codes, perplexity = 10, pca = TRUE)     # perplexity value in t-SNE can be loosely interpreted
                                                          # as the number of close neighbors to each point in the
                                                          # final projection -> 10 was value with the most stable 
                                                          # biologically meaningful projection.

codes_dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2])
codes_dr$code_clustering1 <- factor(code_clustering1)
codes_dr$size <- code_sizes

# Plot t-SNE of the 100 SOM nodes with color set by population assignment and size by # of cells in each node
ggplot(codes_dr, aes(x = tSNE1, y = tSNE2, color = code_clustering1m, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))

# visualization of cluster population frequencies within each sample broken down by the treatment condition

# creating a contingency table that has the total number of cells in each SOM cluster for each sample
cell_count_table <- table(cell_clustering_som,sample_ids)

# normalization of the cell counts within each SOM node for each sample to the total # of cells
# within each sample
cell_freq_table <- t(t(cell_count_table) / colSums(cell_count_table)) * 100
tsne_codes_df <- as.data.frame(cell_freq_table)                       # generates the core df to start visualizing the nodes within each sample separately

mm <- match(tsne_codes_df$sample_ids, sample_metadata$sample_id)                    # matching vector to add treatment condition from sample metadata to the tSNE_codes dataframe
tsne_codes_df$condition <- factor(sample_metadata$condition[mm])                    # adding treatment condition to the dataframe using the matching vector from previous line
tsne_codes_df$code_clustering1 <- factor(code_clustering1m)

ggplot(tsne_codes_df, aes(x = sample_ids, y = Freq, fill = code_clustering1)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ condition, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_manual(values = color_clusters)
